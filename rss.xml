<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title><![CDATA[My Emacs Blog]]></title>
<description><![CDATA[My Emacs Blog]]></description>
<link>https://spepo.github.io/</link>
<lastBuildDate>Sun, 04 May 2025 11:08:27 -0700</lastBuildDate>
<item>
  <title><![CDATA[Towards Auto-Generated ERT Unit Tests]]></title>
  <description><![CDATA[
<p>
Rigorous testing clearly benefits software projects, yet many Emacs Lisp packages have minimal tests. You might think manual testing during development is enough&#x2014;but that only works if the code never changes and has no evolving dependencies. Automated tests, however, give you the confidence to modify code without fear of unintentionally breaking functionality. They quickly catch issues caused by changing dependencies, and coverage tools highlight tested and untested functionality.
</p>

<p>
Benefits aside, writing test cases can feel like a chore. As an enterprise software developer, I disliked it as much as anyone. But now, as I occasionally work on Emacs Lisp packages mostly for personal use, I'm finding that a lack of automated tests costs me valuable time. We've all experienced making seemingly harmless changes, only to discover obscure bugs weeks later that automated tests might have caught immediately.
</p>

<p>
I want automated tests for my Emacs Lisp code&#x2014;whether it’s a published package or just a personal library of functions&#x2014;but I'd rather not write them manually. I've long dreamed of using LLMs to generate test cases. So, is this approach already viable, particularly for Emacs Lisp unit tests? Writing unit tests feels like an ideal scenario for current LLMs that may lack extensive Emacs Lisp training: unit tests are simpler than integration or performance tests, less sensitive to hallucinations, and easy to adjust or discard if problematic. 
</p>

<p>
At this stage, I'm not aiming for a sleek Emacs integration.  I just want to see if the approach works. Using ChatGPT in a browser with some simple copy-pasting is enough. I started by asking ChatGPT (using the <code>o3-mini-high</code> and <code>4o</code> models) to help set up ERT tests for my personal library functions, loaded from my <code>init.el</code>. My goal was to run the tests externally, in batch mode, separate from my main Emacs instance.
</p>

<p>
ChatGPT performed reasonably well. After a few iterations, partly due to peculiarities in my <code>init.el</code> configuration, I ended up with a test file containing a dummy test that I could successfully run externally using:
</p>

<div class="org-src-container">
<pre class="src src-sh">emacs --batch -Q <span style="color: #2544bb;">\</span>
      -l test/test-pp-lib.el <span style="color: #2544bb;">\</span>
      -f ert-run-tests-batch-and-exit
</pre>
</div>

<p>
Next, I gave ChatGPT the code for my <code>/org-next-visible-link</code> function (see   <a href="https://spepo.github.io/2025-03-29-the-tab-key-in-org-mode-reimagined.html">my previous blog post</a>) and asked it to generate a complete suite of unit tests aimed at maximizing coverage. The generated tests looked reasonable, but several failed due to small, silly issues. Some failures were caused by missing double backslashes to properly escape <code>[</code> in <code>looking-at</code> patterns. Others were due to ChatGPT "misunderstanding" the behavior of the function: if point is already at the beginning of a link, <code>/org-next-visible-link</code> will skip to the next one. It was easy enough to fix these manually.
</p>

<p>
However, one test kept failing. It involved text visibility, which is the core aspect that <code>/org-next-visible-link</code> is supposed to handle. I pasted the ERT error and backtrace into ChatGPT and asked it to find the problem. It claimed to have identified and fixed the issue, but the test failed again&#x2014;a common pattern when LLMs hallucinate fixes that don’t actually work.
</p>

<p>
Next, I tried executing the test steps manually in a buffer. The test failed for me too! That’s when I realized the problem might not be in the test, but in my code. I asked ChatGPT to help me find the bug.  I gave it a big hint: during manual testing, I noticed the failure occurred in a specific corner case, when a link was inside a folded section with no text following it. I explained that adding any text after the link would make the test pass. What happened next was quite impressive.
</p>

<p>
ChatGPT took its time performing its inference-based iterative reasoning. It spent about three minutes analyzing the function code, the test code, and the failed test backtrace. When it responded, it correctly identified a bug in my code, explained the underlying problem, and suggested a specific code change to fix it. I applied the fix, and the test passed.
</p>

<blockquote>
<p>
No more excuses: Every non-trivial function deserves a unit test.
</p>
</blockquote>

<p>
For completeness, here is the code of the function under test (with the fix), and the unit tests generated by ChatGPT.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Adapted from org-next-link to only consider visible links</span>
(<span style="color: #5317ac; font-weight: bold;">defun</span> <span style="color: #721045;">/org-next-visible-link</span> (<span style="color: #005a5f; font-weight: bold;">&amp;optional</span> search-backward)
  <span style="color: #2a486a; font-style: italic;">"Move forward to the next visible link.</span>
<span style="color: #2a486a; font-style: italic;">When SEARCH-BACKWARD is non-nil, move backward."</span>
  (<span style="color: #5317ac; font-weight: bold;">interactive</span>)
  (<span style="color: #5317ac; font-weight: bold;">let</span> ((pos (point))
        (search-fun (<span style="color: #5317ac; font-weight: bold;">if</span> search-backward #'re-search-backward
                      #'re-search-forward)))
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Tweak initial position: make sure we do not match current link.</span>
    (<span style="color: #5317ac; font-weight: bold;">cond</span>
     ((<span style="color: #5317ac; font-weight: bold;">and</span> (not search-backward) (looking-at org-link-any-re))
      (goto-char (match-end 0)))
     (search-backward
      (<span style="color: #5317ac; font-weight: bold;">pcase</span> (org-in-regexp org-link-any-re nil t)
        (`(,beg . ,_) (goto-char beg)))))
    (<span style="color: #5317ac; font-weight: bold;">catch</span> <span style="color: #0000c0;">:found</span>
      (<span style="color: #5317ac; font-weight: bold;">while</span> (funcall search-fun org-link-any-re nil t)
        (<span style="color: #5317ac; font-weight: bold;">let</span> ((folded (org-invisible-p (match-beginning 0) t)))
          (<span style="color: #5317ac; font-weight: bold;">when</span> (<span style="color: #5317ac; font-weight: bold;">or</span> (not folded) (eq folded 'org-link))
            (<span style="color: #5317ac; font-weight: bold;">let</span> ((context (<span style="color: #5317ac; font-weight: bold;">save-excursion</span>
                             (<span style="color: #5317ac; font-weight: bold;">unless</span> search-backward (forward-char -1))
                             (org-element-context))))
              (<span style="color: #5317ac; font-weight: bold;">pcase</span> (org-element-lineage context '(link) t)
                (link
                 (goto-char (org-element-property <span style="color: #8f0075; font-weight: bold;">:begin</span> link))
                 (<span style="color: #5317ac; font-weight: bold;">throw</span> <span style="color: #0000c0;">:found</span> t)))))))
      (goto-char pos)
      <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">No further link found</span>
      nil)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #505050; font-style: italic;">;;; </span><span style="color: #505050; font-style: italic;">test-pp-lib.el &#8212;&#8211;&#8211; tests for pp-lib.el</span>

<span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Ensure test directory is on load-path so we can require test-helper</span>
(add-to-list 'load-path (file-name-directory #$))

(<span style="color: #5317ac; font-weight: bold;">require</span> '<span style="color: #0000c0;">test-helper</span>)
(<span style="color: #5317ac; font-weight: bold;">require</span> '<span style="color: #0000c0;">ert</span>)
(<span style="color: #5317ac; font-weight: bold;">require</span> '<span style="color: #0000c0;">org</span>)     <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">for org-mode, org-element, org-link-any-re</span>
(<span style="color: #5317ac; font-weight: bold;">require</span> '<span style="color: #0000c0;">cl-lib</span>)  <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">for cl-letf</span>

<span style="color: #505050; font-style: italic;">;;; </span><span style="color: #505050; font-style: italic;">tests for `</span><span style="color: #0000c0; font-style: italic;">/org-next-visible-link</span><span style="color: #505050; font-style: italic;">'</span>

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-forward-basic</span> ()
  <span style="color: #2a486a; font-style: italic;">"Move to the first link in forward direction and return non-nil."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"foo [[A]] bar [[B]] baz"</span>)
    (org-mode)
    (goto-char (point-min))
    (should (/org-next-visible-link))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">A\\</span><span style="color: #2544bb;">]\\]"</span>))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-forward-second-link</span> ()
  <span style="color: #2a486a; font-style: italic;">"Subsequent `</span><span style="color: #0000c0; font-style: italic;">org-next-visible-link</span><span style="color: #2a486a; font-style: italic;">' should find the next link."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"foo [[A]] bar [[B]] baz"</span>)
    (org-mode)
    (goto-char (point-min))
    (/org-next-visible-link)
    (should (/org-next-visible-link))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">B\\</span><span style="color: #2544bb;">]\\]"</span>))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-forward-skip-current</span> ()
  <span style="color: #2a486a; font-style: italic;">"When point is at the beginning of a link, skip it and find the next."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"[[A]] [[B]]"</span>)
    (org-mode)
    (goto-char (point-min))
    (should (/org-next-visible-link))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">B\\</span><span style="color: #2544bb;">]\\]"</span>))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-backward-basic</span> ()
  <span style="color: #2a486a; font-style: italic;">"Move backward to the nearest previous link and return non-nil."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"first [[A]] then [[B]] then [[C]]"</span>)
    (org-mode)
    (goto-char (point-max))
    (should (/org-next-visible-link t))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">C\\</span><span style="color: #2544bb;">]\\]"</span>))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-backward-second-link</span> ()
  <span style="color: #2a486a; font-style: italic;">"Second backward invocation finds the prior link."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"[[A]] [[B]]"</span>)
    (org-mode)
    (goto-char (point-max))
    (/org-next-visible-link t)
    (should (/org-next-visible-link t))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">A\\</span><span style="color: #2544bb;">]\\]"</span>))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-backward-skip-current</span> ()
  <span style="color: #2a486a; font-style: italic;">"When point is on a link, backward skips it and finds the previous."</span>  
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"[[X]] [[Y]]"</span>)
    (org-mode)
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">position right at the beginning of Y</span>
    (goto-char (point-min))
    (/org-next-visible-link) <span style="color: #505050; font-style: italic;">; </span><span style="color: #505050; font-style: italic;">forward to [[X]]</span>
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">now move to Y</span>
    (/org-next-visible-link)
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">test backward skip</span>
    (goto-char (point))
    (should (/org-next-visible-link t))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">X\\</span><span style="color: #2544bb;">]\\]"</span>))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-no-link</span> ()
  <span style="color: #2a486a; font-style: italic;">"With no links, returns nil and point does not move."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"no links here"</span>)
    (org-mode)
    (goto-char (point-min))
    (should-not (/org-next-visible-link))
    (should (= (point) (point-min)))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-skip-in-folded-headline</span> ()
  <span style="color: #2a486a; font-style: italic;">"Skip links that reside in a folded headline body."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (org-mode)
    (insert <span style="color: #2544bb;">"* Heading1\n[[SKIP]]\n* Heading2\n[[FIND]]\n"</span>)
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Fold the first subtree so its body (and the [[SKIP]] link) is hidden</span>
    (goto-char (point-min))
    (org-cycle)  <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">this folds the subtree under Heading1</span>
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Now search forward: should skip [[SKIP]] and land on [[FIND]]</span>
    (goto-char (point-min))
    (should (/org-next-visible-link))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">FIND\\</span><span style="color: #2544bb;">]\\]"</span>))
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">And then no more</span>
    (should-not (/org-next-visible-link))))

(<span style="color: #5317ac; font-weight: bold;">ert-deftest</span> <span style="color: #721045;">org-next-visible-link-allow-org-link-invisible</span> ()
  <span style="color: #2a486a; font-style: italic;">"Find links hidden with `</span><span style="color: #0000c0; font-style: italic;">invisible=</span><span style="color: #2a486a; font-style: italic;">'org-link` overlays."</span>
  (<span style="color: #5317ac; font-weight: bold;">with-temp-buffer</span>
    (insert <span style="color: #2544bb;">"foo [[HIDDEN]] [[VISIBLE]]"</span>)
    (org-mode)
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">hide first link with 'org-link</span>
    (goto-char (point-min))
    (re-search-forward org-link-any-re)
    (<span style="color: #5317ac; font-weight: bold;">let</span> ((ov (make-overlay (match-beginning 0) (match-end 0))))
      (overlay-put ov 'invisible 'org-link))
    (goto-char (point-min))
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">should still hit HIDDEN first</span>
    (should (/org-next-visible-link))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">HIDDEN\\</span><span style="color: #2544bb;">]\\]"</span>))
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">then hit VISIBLE</span>
    (should (/org-next-visible-link))
    (should (looking-at <span style="color: #2544bb;">"\\[\\[</span><span style="color: #0000c0;">VISIBLE\\</span><span style="color: #2544bb;">]\\]"</span>))
    (should-not (/org-next-visible-link))))

<span style="color: #505050; font-style: italic;">;;; </span><span style="color: #505050; font-style: italic;">test-pp-lib.el ends here</span>
</pre>
</div>

<p>
Even with the current generation of ChatGPT models, I can confidently say they can be used to generate useful ERT unit tests. Is it perfect? Of course not. For example, the <code>org-next-visible-link-backward-skip-current</code> test contains a bug that, only by chance, doesn’t cause a failure. It also includes a useless <code>(goto-char (point))</code> call. Future LLMs will only get better: they’ll be able to fix or improve existing tests and generate new ones to increase code coverage. And tighter integration with Emacs, eventually reaching the point where tests are fully auto-generated, is just a matter of time.
</p>

<p>
There's no need to wait, though. I am sure existing tools like <code>gptel.el</code> and <code>aider.el</code> could already be used to provide a tighter integration experience, if desired. Experimenting with other LLM providers and their models might also yield even better unit test generation results.
</p>

<p>
Meanwhile, I'm off to work on improving my ERT setup to streamline running tests and debugging my code. From now on, all the Emacs Lisp code I work on will be accompanied by unit tests. I encourage you to do the same.
</p>

<blockquote>
<p>
Enjoy the malleability of Emacs and the freedom it gives you!
</p>
</blockquote>

<p>
Discuss this post on <a href="https://www.reddit.com/r/emacs/comments/1jmroa6/the_tab_key_in_org_mode_reimagined/">Reddit</a>.
</p>
<div class="taglist"><a href="https://spepo.github.io/tags.html">Tags</a>: <a href="https://spepo.github.io/tag-emacs.html">emacs</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <link>https://spepo.github.io/2025-04-30-towards-auto-generated-ert-unit-tests.html</link>
  <guid>https://spepo.github.io/2025-04-30-towards-auto-generated-ert-unit-tests.html</guid>
  <pubDate>Wed, 30 Apr 2025 11:14:00 -0700</pubDate>
</item>
<item>
  <title><![CDATA[The TAB Key in Org Mode, Reimagined]]></title>
  <description><![CDATA[
<p>
I don't know about you, but when I'm reading something in an Org file and spot a link I want to follow, I instinctively press <code>TAB</code> to jump to it&#x2014;just like I would in an Info or Help buffer. Using <code>TAB</code> for such field navigation is a common pattern across many applications, including Emacs.  It’s also nicely symmetric with Shift-TAB (<code>S-TAB</code>), which typically navigates backward. But in Org mode, <code>TAB</code> triggers local visibility cycling: folding and unfolding text under the current headline. <code>S-TAB</code> cycles visibility globally, folding and unfolding all the headlines. (Granted, if you don’t use Info or navigate Help buffers with <code>TAB</code>, you might not miss that behavior in Org mode.)
</p>

<p>
See, we have this dichotomy in Org mode: it's both an authoring tool and a task/notes manager. For document authoring, Org markup serves as a source format that's later exported for publishing. In this context, visibility cycling is essential for managing structure and reducing distractions while writing.  As a task and notes manager, Org is used to track notes, TODO lists, schedules, and data&#x2014;content that's often read in place and never exported. Visibility cycling still helps, but it's generally less critical than in authoring mode.
</p>

<p>
This reading workflow within Org files makes me long for features found in more reading-focused modes. Sure, I don’t treat my Org files as read-only; reading and editing are fluidly intertwined. Still, when I'm focused on reading, I want the <code>TAB</code> key to handle navigation, not headline visibility cycling. And I don't want to switch to another mode like View mode just to get a better reading experience.
</p>

<p>
It's well known that the <code>TAB</code> key is heavily overloaded in Emacs, especially in Org mode. Depending on context and configuration, it can perform one of four types of actions: line indentation, candidate completion (during editing), or field navigation and visibility cycling (during reading). As mentioned earlier, <code>TAB</code> is commonly used for field navigation in Info and Help modes. But note that even Org mode uses it this way within tables. Its association with visibility cycling was unique to Org mode until recently, when it was made an option in Outline mode too.
</p>

<p>
Personally, I want to move in the opposite direction: removing visibility cycling from the list of <code>TAB</code>-triggered actions. Three types of behavior are already plenty. I'd rather assign visibility control to a more complex keybinding and prioritize field navigation instead. I'm not a big fan of cycling in general (see <a href="https://spepo.github.io/2025-02-18-speed-dial-your-favorite-files.html">my previous blog post</a>), and would prefer to jump directly to specific folding levels. I also value consistency in keybindings, so unifying <code>TAB</code> behavior across modes is important to me.
</p>

<blockquote>
<p>
<code>TAB</code>: indentation and completion when editing; field navigation when reading
</p>
</blockquote>

<p>
I decided to give it a try and remap <code>TAB</code> in Org mode to primarily perform field navigation. What exactly is considered a “field” is largely up to the user. In general, it should be a structural element in a file where a non-trivial action can be performed, making it useful to have an easy way to jump between them.  For my setup, I chose to treat only links and headlines as fields, similar to how Info handles navigation. Of course, others might include property drawers, code blocks, custom buttons, or other interactive elements. I wouldn't overdo it though&#x2014;too many fields and <code>TAB</code> navigation loses its utility.
</p>

<p>
I remapped <code>TAB</code> in Org mode to navigate to the next visible heading or link, and <code>S-TAB</code> to move to the previous one. Headlines and links inside folded sections are skipped. For visibility cycling, I now rely on Org Speed Keys (a built in feature of Org mode).
</p>

<p>
Speed Keys let you trigger commands with a single keystroke when the point is at the beginning of a headline. They’re off by default but incredibly handy once enabled. A number of keys are predefined out of the box; for example, <code>c</code> is already mapped to <code>org-cycle</code>, which is what <code>TAB</code> normally does in Org mode.
</p>

<p>
I’ve had Speed Keys enabled for ages (mainly using them for forward/backward headline navigation), but I had never used <code>c</code> for visibility cycling&#x2014;until now. And it gets even better: the combination of <code>TAB</code> / <code>S-TAB</code> to jump between fields, followed by a speed key at the headline, turns out to be quite powerful.
</p>

<p>
What about the other actions <code>TAB</code> usually performs in Org files?  For now, I rely on <code>M-x org-cycle</code> when needed. The <code>org-cycle</code> command is quite sophisticated and can fall back to other <code>TAB</code> behaviors like indentation when appropriate.  That said, I’ve been using my custom <code>TAB</code> / <code>S-TAB</code> bindings for months now and haven’t run into any situations where I missed the default behavior.
</p>

<p>
Want to give it a try? Here’s the code you can drop into your <code>init.el</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #5317ac; font-weight: bold;">defun</span> <span style="color: #721045;">/org-next-visible-heading-or-link</span> (<span style="color: #005a5f; font-weight: bold;">&amp;optional</span> arg)
  <span style="color: #2a486a; font-style: italic;">"Move to the next visible heading or link, whichever comes first.</span>
<span style="color: #2a486a; font-style: italic;">With prefix ARG and the point on a heading(link): jump over subsequent</span>
<span style="color: #2a486a; font-style: italic;">headings(links) to the next link(heading), respectively.  This is useful</span>
<span style="color: #2a486a; font-style: italic;">to skip over a long series of consecutive headings(links)."</span>
  (<span style="color: #5317ac; font-weight: bold;">interactive</span> <span style="color: #2544bb;">"P"</span>)
  (<span style="color: #5317ac; font-weight: bold;">let</span> ((next-heading (<span style="color: #5317ac; font-weight: bold;">save-excursion</span>
                        (org-next-visible-heading 1)
                        (<span style="color: #5317ac; font-weight: bold;">when</span> (org-at-heading-p) (point))))
        (next-link (<span style="color: #5317ac; font-weight: bold;">save-excursion</span>
                     (<span style="color: #5317ac; font-weight: bold;">when</span> (/org-next-visible-link) (point)))))
    (<span style="color: #5317ac; font-weight: bold;">when</span> arg
      (<span style="color: #5317ac; font-weight: bold;">if</span> (<span style="color: #5317ac; font-weight: bold;">and</span> (org-at-heading-p) next-link)
          (<span style="color: #5317ac; font-weight: bold;">setq</span> next-heading nil)
        (<span style="color: #5317ac; font-weight: bold;">if</span> (<span style="color: #5317ac; font-weight: bold;">and</span> (looking-at org-link-any-re) next-heading)
            (<span style="color: #5317ac; font-weight: bold;">setq</span> next-link nil))))
    (<span style="color: #5317ac; font-weight: bold;">cond</span>
     ((<span style="color: #5317ac; font-weight: bold;">and</span> next-heading next-link) (goto-char (min next-heading next-link)))
     (next-heading (goto-char next-heading))
     (next-link (goto-char next-link)))))

(<span style="color: #5317ac; font-weight: bold;">defun</span> <span style="color: #721045;">/org-previous-visible-heading-or-link</span> (<span style="color: #005a5f; font-weight: bold;">&amp;optional</span> arg)
  <span style="color: #2a486a; font-style: italic;">"Move to the previous visible heading or link, whichever comes first.</span>
<span style="color: #2a486a; font-style: italic;">With prefix ARG and the point on a heading(link): jump over subsequent</span>
<span style="color: #2a486a; font-style: italic;">headings(links) to the previous link(heading), respectively.  This is useful</span>
<span style="color: #2a486a; font-style: italic;">to skip over a long series of consecutive headings(links)."</span>
  (<span style="color: #5317ac; font-weight: bold;">interactive</span> <span style="color: #2544bb;">"P"</span>)
  (<span style="color: #5317ac; font-weight: bold;">let</span> ((prev-heading (<span style="color: #5317ac; font-weight: bold;">save-excursion</span>
                        (org-previous-visible-heading 1)
                        (<span style="color: #5317ac; font-weight: bold;">when</span> (org-at-heading-p) (point))))
        (prev-link (<span style="color: #5317ac; font-weight: bold;">save-excursion</span>
                     (<span style="color: #5317ac; font-weight: bold;">when</span> (/org-next-visible-link t) (point)))))
    (<span style="color: #5317ac; font-weight: bold;">when</span> arg
      (<span style="color: #5317ac; font-weight: bold;">if</span> (<span style="color: #5317ac; font-weight: bold;">and</span> (org-at-heading-p) prev-link)
          (<span style="color: #5317ac; font-weight: bold;">setq</span> prev-heading nil)
        (<span style="color: #5317ac; font-weight: bold;">if</span> (<span style="color: #5317ac; font-weight: bold;">and</span> (looking-at org-link-any-re) prev-heading)
            (<span style="color: #5317ac; font-weight: bold;">setq</span> prev-link nil))))
    (<span style="color: #5317ac; font-weight: bold;">cond</span>
     ((<span style="color: #5317ac; font-weight: bold;">and</span> prev-heading prev-link) (goto-char (max prev-heading prev-link)))
     (prev-heading (goto-char prev-heading))
     (prev-link (goto-char prev-link)))))

<span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Adapted from org-next-link to only consider visible links</span>
(<span style="color: #5317ac; font-weight: bold;">defun</span> <span style="color: #721045;">/org-next-visible-link</span> (<span style="color: #005a5f; font-weight: bold;">&amp;optional</span> search-backward)
  <span style="color: #2a486a; font-style: italic;">"Move forward to the next visible link.</span>
<span style="color: #2a486a; font-style: italic;">When SEARCH-BACKWARD is non-nil, move backward."</span>
  (<span style="color: #5317ac; font-weight: bold;">interactive</span>)
  (<span style="color: #5317ac; font-weight: bold;">let</span> ((pos (point))
        (search-fun (<span style="color: #5317ac; font-weight: bold;">if</span> search-backward #'re-search-backward
                      #'re-search-forward)))
    <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Tweak initial position: make sure we do not match current link.</span>
    (<span style="color: #5317ac; font-weight: bold;">cond</span>
     ((<span style="color: #5317ac; font-weight: bold;">and</span> (not search-backward) (looking-at org-link-any-re))
      (goto-char (match-end 0)))
     (search-backward
      (<span style="color: #5317ac; font-weight: bold;">pcase</span> (org-in-regexp org-link-any-re nil t)
        (`(,beg . ,_) (goto-char beg)))))
    (<span style="color: #5317ac; font-weight: bold;">catch</span> <span style="color: #0000c0;">:found</span>
      (<span style="color: #5317ac; font-weight: bold;">while</span> (funcall search-fun org-link-any-re nil t)
        (<span style="color: #5317ac; font-weight: bold;">let</span> ((folded (org-invisible-p nil t)))
          (<span style="color: #5317ac; font-weight: bold;">when</span> (<span style="color: #5317ac; font-weight: bold;">or</span> (not folded) (eq folded 'org-link))
            (<span style="color: #5317ac; font-weight: bold;">let</span> ((context (<span style="color: #5317ac; font-weight: bold;">save-excursion</span>
                             (<span style="color: #5317ac; font-weight: bold;">unless</span> search-backward (forward-char -1))
                             (org-element-context))))
              (<span style="color: #5317ac; font-weight: bold;">pcase</span> (org-element-lineage context '(link) t)
                (link
                 (goto-char (org-element-property <span style="color: #8f0075; font-weight: bold;">:begin</span> link))
                 (<span style="color: #5317ac; font-weight: bold;">throw</span> <span style="color: #0000c0;">:found</span> t)))))))
      (goto-char pos)
      <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">No further link found</span>
      nil)))

(<span style="color: #5317ac; font-weight: bold;">defun</span> <span style="color: #721045;">/org-shifttab</span> (<span style="color: #005a5f; font-weight: bold;">&amp;optional</span> arg)
  <span style="color: #2a486a; font-style: italic;">"Move to the previous visible heading or link.</span>
<span style="color: #2a486a; font-style: italic;">If already at a heading, move first to its beginning.  When inside a table,</span>
<span style="color: #2a486a; font-style: italic;">move to the previous field."</span>
  (<span style="color: #5317ac; font-weight: bold;">interactive</span> <span style="color: #2544bb;">"P"</span>)
  (<span style="color: #5317ac; font-weight: bold;">cond</span>
   ((org-at-table-p) (call-interactively #'org-table-previous-field))
   ((<span style="color: #5317ac; font-weight: bold;">and</span> (not (bolp)) (org-at-heading-p)) (beginning-of-line))
   (t (call-interactively #'/org-previous-visible-heading-or-link))))

(<span style="color: #5317ac; font-weight: bold;">defun</span> <span style="color: #721045;">/org-tab</span> (<span style="color: #005a5f; font-weight: bold;">&amp;optional</span> arg)
  <span style="color: #2a486a; font-style: italic;">"Move to the next visible heading or link.</span>
<span style="color: #2a486a; font-style: italic;">When inside a table, re-align the table and move to the next field."</span>
  (<span style="color: #5317ac; font-weight: bold;">interactive</span>)
  (<span style="color: #5317ac; font-weight: bold;">cond</span>
   ((org-at-table-p) (org-table-justify-field-maybe)
    (call-interactively #'org-table-next-field))
   (t (call-interactively #'/org-next-visible-heading-or-link))))

(<span style="color: #5317ac; font-weight: bold;">use-package</span> <span style="color: #0000c0;">org</span>
  <span style="color: #8f0075; font-weight: bold;">:config</span>
  <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">RET should follow link when possible (moves to next field in tables)</span>
  (<span style="color: #5317ac; font-weight: bold;">setq</span> org-return-follows-link t)
  <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">must be at the beginning of a headline to use it; ? for help</span>
  (<span style="color: #5317ac; font-weight: bold;">setq</span> org-use-speed-commands t)
  <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Customize some bindings</span>
  (define-key org-mode-map (kbd <span style="color: #2544bb;">"&lt;tab&gt;"</span>) #'/org-tab)
  (define-key org-mode-map (kbd <span style="color: #2544bb;">"&lt;backtab&gt;"</span>) #'/org-shifttab)
  <span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Customize speed keys: modifying operations must be upper case</span>
  (custom-set-variables
   '(org-speed-commands
     '((<span style="color: #2544bb;">"Outline Navigation and Visibility"</span>)
       (<span style="color: #2544bb;">"n"</span> . (org-speed-move-safe 'org-next-visible-heading))
       (<span style="color: #2544bb;">"p"</span> . (org-speed-move-safe 'org-previous-visible-heading))
       (<span style="color: #2544bb;">"f"</span> . (org-speed-move-safe 'org-forward-heading-same-level))
       (<span style="color: #2544bb;">"b"</span> . (org-speed-move-safe 'org-backward-heading-same-level))
       (<span style="color: #2544bb;">"u"</span> . (org-speed-move-safe 'outline-up-heading))
       (<span style="color: #2544bb;">"j"</span> . org-goto)
       (<span style="color: #2544bb;">"c"</span> . org-cycle)
       (<span style="color: #2544bb;">"C"</span> . org-shifttab)
       (<span style="color: #2544bb;">" "</span> . org-display-outline-path)
       (<span style="color: #2544bb;">"s"</span> . org-toggle-narrow-to-subtree)
       (<span style="color: #2544bb;">"Editing"</span>)
       (<span style="color: #2544bb;">"I"</span> . (<span style="color: #5317ac; font-weight: bold;">progn</span> (forward-char 1) (call-interactively 'org-insert-heading-respect-content)))
       (<span style="color: #2544bb;">"^"</span> . org-sort)
       (<span style="color: #2544bb;">"W"</span> . org-refile)
       (<span style="color: #2544bb;">"@"</span> . org-mark-subtree)
       (<span style="color: #2544bb;">"T"</span> . org-todo)
       (<span style="color: #2544bb;">":"</span> . org-set-tags-command)
       (<span style="color: #2544bb;">"Misc"</span>)
       (<span style="color: #2544bb;">"?"</span> . org-speed-command-help))))
  )
</pre>
</div>

<p>
A few comments about the code, for those interested:
</p>
<ol class="org-ol">
<li>This is more of a proof-of-concept than optimized code ready for upstreaming.</li>
<li>My <code>/org-next-visible-link</code> is a simplified version of the built-in <code>org-next-link</code>, tailored to the specific cases I care about. Honestly, I was surprised that <code>org-next-link</code> doesn’t already do what I need.  It jumps to the next link even if it’s inside a folded section, causing it to unfold. I have a hard time imagining why would anyone need that.</li>
<li>In <code>/org-tab</code> and <code>/org-shifttab</code>, I preserved the default behavior of <code>org-cycle</code> within a table: it navigates between table fields.</li>
<li>I’ve also customized <code>org-speed-commands</code> to only bind editing actions to keys that require the Shift modifier. I like keeping lowercase keys reserved for non-destructive commands. As a next step, I may remap Space and Shift-Space to scroll the buffer. That would bring me even closer to a more consistent reading experience.</li>
</ol>

<blockquote>
<p>
Enjoy the malleability of Emacs and the freedom it gives you!
</p>
</blockquote>

<p>
Discuss this post on <a href="https://www.reddit.com/r/emacs/comments/1jmroa6/the_tab_key_in_org_mode_reimagined/">Reddit</a>.
</p>
<div class="taglist"><a href="https://spepo.github.io/tags.html">Tags</a>: <a href="https://spepo.github.io/tag-emacs.html">emacs</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <link>https://spepo.github.io/2025-03-29-the-tab-key-in-org-mode-reimagined.html</link>
  <guid>https://spepo.github.io/2025-03-29-the-tab-key-in-org-mode-reimagined.html</guid>
  <pubDate>Sat, 29 Mar 2025 08:01:00 -0700</pubDate>
</item>
<item>
  <title><![CDATA[Speed Dialing Your Favorite Files]]></title>
  <description><![CDATA[
<p>
I may be dating myself, but I vividly remember setting up speed dials for my most frequently called numbers on my AT&amp;T landline phone. In the early '90s, you could store a phone number in a numbered memory slot (referred to as "programming") and later dial your grandma, for example, by pressing <code>SPD+2</code>. Retro is in&#x2014;so if you're too young to remember that and want to know more, just ask your favorite LLM chatbot to fill you in.
</p>

<p>
Speed-dialing as a user experience concept is widespread, although we don't normally call it that anymore. It is implemented as a feature that I use many times a day in my web browser. I use Safari on a Mac and typically keep many tabs open. I pin the first few to frequently visited URLs, like <a href="https://planet.emacslife.com">https://planet.emacslife.com</a>. I can quickly switch to one of them using the keyboard shortcut <code>CMD+1..9</code>, always knowing which website I'll get. Other browsers offer similar functionality, though they may use different shortcuts, like <code>CTRL+1..9</code>.
</p>

<p>
The two apps I use most often on my Mac are Safari and Emacs, and I wondered, “Why don't I have a similar speed-dialing feature in Emacs?” It would be incredibly useful to switch instantly to my important files for reading or jotting down notes. I also like to optimize my keybindings, and consistency plays a big role in that&#x2014;whether it’s adopting Emacs keybindings elsewhere or bringing external shortcuts into Emacs. It would be great to use the same <code>CMD+1..9</code> shortcut to recreate this functionality in Emacs.
</p>

<p>
But doesn’t Emacs already have Tab Bar and Tab Line features? Maybe one of them (I can never remember which is which) could be adapted or enhanced to do what I want. Note, however, that I’m talking about speed dialing files, not tabs. I don’t want to select a tab or cycle through them&#x2014;I want to jump directly to a specific buffer that’s visiting a specific file. Tabs feel a bit unnatural in Emacs; they make sense in browsers, but in Emacs, we typically work with buffers by name.
</p>

<p>
Direct addressing&#x2014;using a name or a short index&#x2014;is both powerful and highly efficient. Cycling is the least efficient method (looking at you, <code>CMD+TAB</code>). Completion is a middle ground&#x2014;it requires extra keystrokes compared to direct addressing and is less predictable when the candidate list changes (in how many characters must be typed to get a single match).  However, it’s essential when the list of candidates is long.
</p>

<blockquote>
<p>
Direct Addressing &gt; Completion &gt; Cycling
</p>
</blockquote>

<p>
In general, I prefer direct addressing whenever possible, completion when necessary, and cycling only as a last resort. Emacs' built-in <code>bookmark-jump</code> falls into the completion category. It would be my next choice if the number of my frequently used files was above ten.
</p>

<p>
Another reason I avoid using tabs for this in Emacs is that I don’t want to waste screen real estate on a tab bar if I don’t have to. My speed dials are mostly static&#x2014;I may change them occasionally, but if I assign <code>1</code> to <code>school.org</code> and <code>2</code> to <code>house.org</code>, I want to stick with that. Thanks to muscle memory, I don’t need to see the list in front of me at all times. Plus, accidentally switching to the wrong frequently used file isn’t a big deal&#x2014;I can quickly flip through a few of them to find what I need.
</p>

<p>
The beauty of Emacs is that I can create a Safari-like speed-dial experience with just a couple of elisp expressions in my <code>init.el</code> file.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #505050; font-style: italic;">;;</span>
<span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Speed Dialing Favorite Files</span>
<span style="color: #505050; font-style: italic;">;;</span>
(<span style="color: #5317ac; font-weight: bold;">defvar</span> <span style="color: #00538b;">/speed-dial-list</span>
  '((<span style="color: #2544bb;">"&#9461;-todo"</span> . <span style="color: #2544bb;">"~/todo.org"</span>)
    (<span style="color: #2544bb;">"&#9462;-emacs"</span> . <span style="color: #2544bb;">"~/para/areas/emacs.org"</span>)
    (<span style="color: #2544bb;">"&#9463;-family"</span> . <span style="color: #2544bb;">"~/para/areas/family.org"</span>)
    (<span style="color: #2544bb;">"&#9464;-house"</span> . <span style="color: #2544bb;">"~/para/areas/house.org"</span>)
    (<span style="color: #2544bb;">"&#9465;-garden"</span> . <span style="color: #2544bb;">"~/para/areas/garden.org"</span>)
    (<span style="color: #2544bb;">"&#9466;-42"</span> . <span style="color: #2544bb;">"~/para/areas/42.org"</span>)
    (<span style="color: #2544bb;">"&#9467;-init"</span> . <span style="color: #2544bb;">"~/.emacs.d/init.el"</span>)
    (<span style="color: #2544bb;">"&#9468;-O1"</span> . <span style="color: #2544bb;">"~/para/projects/proj1.org"</span>)
    (<span style="color: #2544bb;">"&#9469;-O2"</span> . <span style="color: #2544bb;">"~/para/projects/proj2.org"</span>)
    (<span style="color: #2544bb;">"&#9470;-O3"</span> . <span style="color: #2544bb;">"~/para/projects/proj3.org"</span>))
  <span style="color: #2a486a; font-style: italic;">"List of speed-dial entries as (LABEL . FILENAME)."</span>)

<span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Global keybindings for speed dialing using '</span><span style="color: #0000c0; font-style: italic;">&lt;Super&gt;</span><span style="color: #505050; font-style: italic;">' + digit</span>
(<span style="color: #5317ac; font-weight: bold;">let</span> ((i 1))
  (<span style="color: #5317ac; font-weight: bold;">dolist</span> (entry /speed-dial-list)
    (keymap-global-set (format <span style="color: #2544bb;">"s-%d"</span> (mod i 10))
                       `(<span style="color: #5317ac; font-weight: bold;">lambda</span>() (<span style="color: #5317ac; font-weight: bold;">interactive</span>) (find-file-existing ,(cdr entry))))
    (<span style="color: #5317ac; font-weight: bold;">setq</span> i (1+ i))))
</pre>
</div>

<p>
As you can see, I use the <code>&lt;Super&gt;</code> key modifier to define bindings that match my Safari shortcuts, <code>CMD+1..9</code>. Note a little trick: using the mod function inside <code>keymap-global-set</code> to get <code>s-0</code> to invoke the tenth speed-dial entry.
</p>

<p>
Currently, the speed-dial bindings simply call the <code>find-file-existing</code> function to switch to the corresponding buffer, opening the file if needed. But you can customize this further by using your own function for tailored behavior.
</p>

<p>
For example, you might use repeated presses of the same <code>CMD+0..9</code> to change folding in an Org buffer, jump to a predefined heading, switch to a related buffer, or perform other context-specific actions.
</p>

<figure>
<img src="https://spepo.github.io/static/2025-02/speed_dialing_screenshot1.png" alt="speed_dialing_screenshot.png">
</figure>

<p>
Rather than visualizing the speed-dial entries as tabs, I found a way to display them without taking up valuable screen real estate. I simply splice the speed-dial labels into the Emacs frame title bar, which I don't really use for anything else. By default, it shows the current buffer name, but that information is also displayed in the mode line, which is where my eyes naturally go.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #505050; font-style: italic;">;; </span><span style="color: #505050; font-style: italic;">Inject my speed-dial list into the frame title</span>
(<span style="color: #5317ac; font-weight: bold;">setq</span> frame-title-format (concat (mapconcat #'car /speed-dial-list <span style="color: #2544bb;">"  "</span>)
                                 <span style="color: #2544bb;">" - %b"</span>))
</pre>
</div>

<p>
For my needs, displaying speed-dial entries in the Emacs frame title, followed by the current buffer name, works perfectly. My main Emacs frame is always wide enough to accommodate it. If I couldn’t use the frame title, I’d probably just open my <code>init.el</code> whenever I needed to check which speed-dial number maps to which file. But you might find an even better approach that works for you.
</p>

<blockquote>
<p>
Enjoy the malleability of Emacs and the freedom it gives you!
</p>
</blockquote>

<p>
Discuss this post on <a href="https://www.reddit.com/r/emacs/comments/1iskl3w/speed_dialing_your_favorite_files/">Reddit</a>.
</p>
<div class="taglist"><a href="https://spepo.github.io/tags.html">Tags</a>: <a href="https://spepo.github.io/tag-emacs.html">emacs</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <link>https://spepo.github.io/2025-02-18-speed-dial-your-favorite-files.html</link>
  <guid>https://spepo.github.io/2025-02-18-speed-dial-your-favorite-files.html</guid>
  <pubDate>Tue, 18 Feb 2025 10:46:00 -0800</pubDate>
</item>
</channel>
</rss>
